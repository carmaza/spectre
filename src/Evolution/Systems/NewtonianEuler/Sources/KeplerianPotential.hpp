// Distributed under the MIT License.
// See LICENSE.txt for details.

#pragma once

#include <cstddef>
#include <limits>
#include <pup.h>
#include <string>

#include "DataStructures/Tensor/TypeAliases.hpp"
#include "Domain/Tags.hpp"
#include "Evolution/Systems/NewtonianEuler/TagsDeclarations.hpp"
#include "Options/Options.hpp"
#include "Utilities/MakeArray.hpp"
#include "Utilities/TMPL.hpp"

/// \cond
class DataVector;

namespace gsl {
template <typename T>
class not_null;
}  // namespace gsl
/// \endcond

namespace NewtonianEuler {
namespace Sources {

/*!
 * \brief Source produced by a Keplerian potential.
 *
 * This class implements the source terms generated by a Keplerian potential,
 * as proposed in 2-D tests carried out in \cite Schaal2015.
 * The potential exerts an external acceleration \f$a_i = -\partial_i\Phi\f$,
 * so that the evolution equations read
 *
 * \f{align*}
 * \partial_t\rho + \partial_i F^i(\rho) &= 0\\
 * \partial_t S^i + \partial_jF^j(S^i) &= S(S^i)\\
 * \partial_t e + \partial_i F^i(e) &= S(e),
 * \f}
 *
 * where \f$F^i(u)\f$ is the volume flux of the conserved quantity \f$u\f$
 * (see ComputeFluxes), and
 *
 * \f{align*}
 * S(S^i) &= \rho a^i\\
 * S(e) &= S^ia_i.
 * \f}
 *
 * The acceleration is computed as
 *
 * \f{align*}
 * a^i = -\dfrac{x'^i}{r'^3},
 * \f}
 * where \f$x'^i = x^i - x^i_\text{c}\f$ are the coordinates relative to the
 * center of the potential, and \f$r' = \sqrt{x'^ix'_i}\f$ is the radial
 * distance with respect to the center. In order to avoid a singularity
 * near the center of the potential, we apply a smoothing parameter
 * \f$\epsilon > 0\f$ so that,
 *
 * \f{align*}
 * a^i = - \dfrac{x'^i}{r'\left(r'^2 + \epsilon^2\right)}
 * \f}
 *
 * for \f$r' < (1 - \Delta r)/2\f$, with \f$\Delta r\f$ being the transition
 * width of the disk (see Solutions::KeplerianDisk). The singularity itself
 * is further avoided by taking the limit \f$x'^i/r' = 1\f$ for \f$r'\f$
 * small enough to neglect the angular dependency of such a limit.
 * For the latter, we arbitrarily apply the limit for \f$r' < 10^{-15}\f$.
 *
 * \note Although this test is proposed in 2-D, this class also implements
 * a 3-D source, in which case \f$r'\f$ is the 3-D distance from the
 * center of the potential.
 */
template <size_t Dim>
struct KeplerianPotential {
  KeplerianPotential() noexcept = default;
  KeplerianPotential(const KeplerianPotential& /*rhs*/) = default;
  KeplerianPotential& operator=(const KeplerianPotential& /*rhs*/) = default;
  KeplerianPotential(KeplerianPotential&& /*rhs*/) noexcept = default;
  KeplerianPotential& operator=(KeplerianPotential&& /*rhs*/) noexcept =
      default;
  ~KeplerianPotential() = default;

  KeplerianPotential(const std::array<double, Dim>& potential_center,
                     double smoothing_parameter,
                     double transition_width) noexcept;

  // clang-tidy: google-runtime-references
  void pup(PUP::er& /*p*/) noexcept;  // NOLINT

  using sourced_variables = tmpl::list<Tags::MomentumDensity<DataVector, Dim>,
                                       Tags::EnergyDensity<DataVector>>;

  using argument_tags = tmpl::list<Tags::MassDensityCons<DataVector>,
                                   Tags::MomentumDensity<DataVector, Dim>,
                                   ::Tags::Coordinates<Dim, Frame::Inertial>>;

  void apply(gsl::not_null<tnsr::I<DataVector, Dim>*> source_momentum_density,
             gsl::not_null<Scalar<DataVector>*> source_energy_density,
             const Scalar<DataVector>& mass_density_cons,
             const tnsr::I<DataVector, Dim>& momentum_density,
             const tnsr::I<DataVector, Dim>& x) const noexcept;

 private:
  template <size_t SpatialDim>
  friend bool
  operator==(  // NOLINT (clang-tidy: readability-redundant-declaration)
      const KeplerianPotential<SpatialDim>& lhs,
      const KeplerianPotential<SpatialDim>& rhs) noexcept;

  std::array<double, Dim> potential_center_ =
      make_array<Dim>(std::numeric_limits<double>::signaling_NaN());
  double smoothing_parameter_ = std::numeric_limits<double>::signaling_NaN();
  double transition_width_ = std::numeric_limits<double>::signaling_NaN();
};

template <size_t Dim>
bool operator!=(const KeplerianPotential<Dim>& lhs,
                const KeplerianPotential<Dim>& rhs) noexcept;
}  // namespace Sources
}  // namespace NewtonianEuler
